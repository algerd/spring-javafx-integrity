Есть 4 структурных типа видов-контроллеров:
1. Main Controller - главный невнедряемый контейнер вид-контроллер
2. Included Controllers - автоматически компилятором внедряемые в родительский документ с помощью fxml-директивы include
    и в родительский контроллер с помощью заглавной директивы fx:controller самого внедряемого вида.
3. Setted Controllers - вручную динамически(runtime) внедряемые в родительский документ с помощью загрузчиков и сеттер-методов
    родительского контроллера.
4. Dialog Controllers - всплывающие виды окна. Они полностью автономны, никуда не внедряются и виды их создаются загрузчиком.
   
Main Controller, Setted Controllers и Dialog Controllers реализуются только через spring-бины.
Included Controllers могут быть внедряться и через бины, и автономно. Но намного удобнее реализовывать
через бины, тогда внутри их будут доступны другие бины. При этом одновременно используется внутреннее included
внедрение, что очень удобно при работе в Scene Builder и доступны в них другие бины.
Отличный пример такого внедрения: springbootJavaFXTutorial !!!

Вывод: все контроллеры должны быть бинами!
И тогда фабрика бинов контроллера упростится до:

    loader.setControllerFactory(applicationContext::getBean);

Included Controllers применять, когда вьюхи внедряются при компиляции, т.е. статические элементы вида.
Setted Controllers применять при динамическом внедрении вьюх.

Можно Included Controllers внедрять в родительский контроллер и с помощью @Autowired, и с помощью @FXML
но с @FXML не будет использоваться bean, а будет создаваться новый автономный объект? Лучше придерживаться
одного стиля внедрения и т.к. мы используем Spring, то надо внедрять инструментами Spring, т.е. @Autowired.
Included Controllers можно внедрять в родительский контроллер и через конструктор, и через сеттеры(поля).
Для экономии места и лучшей читаемости, лучше через поля. Но возможно в случае возникновения кругового связывания
лучше через конструктор. Впоследвствии сеттер внедрения родителського контроллера в инклюдед контроллер лучше 
перенести в абстрактный класс.

If a class is specified in the fx:controller attribute, and no controller already exists, the FXMLLoader checks for a controllerFactory. 
If one exists, then the controller is set as the result of passing the specified Class to the controllerFactory's call() method, 
otherwise it is created by calling newInstance() on the specified class (effectively calling its no-argument constructor).

Для иклудных контроллеров загрузчик вида и возвращаемый вид не нужны, поэтому нет смысла их наследовать от
суперконтроллера-загрузчика. И Соответственно нет смысла для них использовать специальныую аннотацию с указанием
пути fxml-вида. Но как быть с css для инклудных контроллеров?

Диалоговые вьюхи требуют отдельный подход:
    - Scope - prototype
    - для вызова диалогового контроллера из другого контроллера надо исплльзовать applicationContext.getBean()
        чтобы получать при каждом вызове новый объект диалогового контроллера.
    - поэтому, чтобы не внедрять в каждый контроолер, требующий диалоговый контроллер, applicationContext
        и там же не вызывать у него бин диалогового контроллера, надо создать центральный диалоговый сервис,
        в которм будет внедрён applicationContext и который будет запрашивать необходимый бин.

Диалоговое окно и контроллер, который используется в диалоговом окне надо разделить! 
Диалоговое окно - это отдельный класс, в котором могут использоваться любые контроллеры и диалоговые
и сеттерный. И наоборот, диалоговые контроллеры могут использоваться в главном окне. 
Таким образом, достигается создание автономных окон перетягиванием вьюхи из главного окна:
    - создаётся объект диалогового окна и в него вставляется вьюха из главного окна.
    - и наоборот при перетаскивании диалогового окна на схватываемую область гланого окна вьюха переносится 
    в гланое окно, а диалоговое окно закрывается. 
Для реализации многовкладочного интерфейса и перетягивания окон сеттерных вьюх, надо все сеттерные и диалоговые 
контроллеры делать @Scope("prototype")

